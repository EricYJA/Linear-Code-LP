import numpy as np

def calculate_minimum_distance(G):
    """
    Calculate the minimum distance d(C) of a code generated by the generator matrix G.

    Parameters:
    G (numpy.ndarray): Generator matrix (k x n).

    Returns:
    int: The minimum distance d(C).
    """
    k, n = G.shape
    min_distance = float('inf')  # Start with infinity as the minimum distance

    # Generate all possible input vectors u (2^k combinations for k bits)
    for i in range(1, 2**k):  # Start from 1 to avoid the all-zero vector
        u = np.array([int(b) for b in format(i, f'0{k}b')])  # Binary vector of length k
        codeword = np.dot(u, G)  # Compute the codeword
        hamming_weight = np.sum(codeword != 0)  # Count non-zero elements

        # Update the minimum distance
        if hamming_weight < min_distance:
            min_distance = hamming_weight

    return min_distance


def calculate_a_b_X(G, u, m):
    """
    Calculate a, b, and X for the m-height computation.

    Parameters:
    G (numpy.ndarray): Generator matrix (k x n).
    u (numpy.ndarray): Input vector (1 x k).
    n (int): Length of the codeword (number of columns in G).
    k (int): Number of rows in G (dimension of input vector u).
    m (int): Index for m-height calculation.

    Returns:
    tuple: a (index of largest absolute value),
           b (index of (m+1)-th largest absolute value),
           X (set of indices of the next m-1 largest absolute values).
    """
    # Step 1: Compute the codeword
    c = np.dot(u, G).flatten()  # Compute codeword and flatten it to a 1D array
    
    # Step 2: Sort indices by the absolute values of the elements in descending order
    sorted_indices = np.argsort(-np.abs(c))  # Negative sign for descending order
    
    # Step 3: Determine a, b, and X
    a = sorted_indices[0]  # Index of the largest absolute value
    b = sorted_indices[m]  # Index of the (m+1)-th largest absolute value
    X = sorted(sorted_indices[1:m])  # Indices of the next m-1 largest absolute values

    Y = sorted_indices[m+1:]  # Indices of the remaining elements

    indices = [a] + X + [b]  # Combine a, X, and b
    psi = [1 if c[i] > 0 else -1 for i in indices]  # Get signs of elements at these indices

    tau = [x0] + X + [xm] + Y
    
    return a, b, X, Y, psi, tau

def inverse_permutation(tau):
    """
    Calculate the inverse permutation tau^{-1}.

    Parameters:
    tau (list): A permutation of indices.

    Returns:
    list: The inverse permutation tau^{-1}.
    """
    n = len(tau)
    tau_inv = [0] * n  # Initialize inverse permutation with the same length
    for i, t in enumerate(tau):
        tau_inv[t] = i  # Map the position back to the original index
    return tau_inv


if __name__ == "__main__":
    # Example usage:
    G = np.array([[0.911, 0.03, 1.481, -0.756, 1.249],
                  [-0.049, 0.975, 1.511, -1.303, 0.74]])  # Generator matrix
    d_C = calculate_minimum_distance(G)
    print(f"The minimum distance d(C) is: {d_C}")


    u = np.array([1.2, -0.8])  # Example input vector
    n = G.shape[1]  # Number of columns in G
    k = G.shape[0]  # Number of rows in G
    m = 3  # Index for m-height calculation

    a, b, X, Y, psi, tau = calculate_a_b_X(G, u, m)
    print(f"a: {a}, b: {b}, X: {X}, Y: {Y}, psi: {psi}, tau: {tau}")


